// Generated by CoffeeScript 1.3.1
(function() {
  var BALL_RADIUS, balls, currentBoundaryPoints, drawBoundaries, init, lastTime, mainLoop, normalizePoint, planes, recalculateNormal, render, rotateSquare, rotationAngle, rotationBounds, update, util;

  BALL_RADIUS = 10;

  lastTime = 0;

  rotationAngle = 35;

  util = new Collision.Util;

  rotationBounds = [
    {
      x: -150,
      y: 150
    }, {
      x: 150,
      y: 150
    }, {
      x: 150,
      y: -150
    }, {
      x: -150,
      y: -150
    }
  ];

  currentBoundaryPoints = [
    {
      x: 100,
      y: 100
    }, {
      x: 400,
      y: 100
    }, {
      x: 400,
      y: 400
    }, {
      x: 100,
      y: 400
    }
  ];

  planes = [
    {
      x: 0,
      y: 1,
      dist: 1
    }, {
      x: 1,
      y: 0,
      dist: 1
    }, {
      x: 0,
      y: -1,
      dist: 1
    }, {
      x: -1,
      y: 0,
      dist: 1
    }
  ];

  balls = [
    {
      velocityX: 200,
      velocityY: 100,
      posX: 250,
      posY: 250
    }, {
      velocityX: -200,
      velocityY: 400,
      posX: 250,
      posY: 250
    }, {
      velocityX: 100,
      velocityY: -200,
      posX: 250,
      posY: 250
    }, {
      velocityX: 100,
      velocityY: -300,
      posX: 250,
      posY: 250
    }
  ];

  drawBoundaries = function() {
    var context, point, _i, _len;
    context = document.getElementById("bounds").getContext('2d');
    context.beginPath();
    context.strokeStyle = "#000";
    context.moveTo(currentBoundaryPoints[3].x, currentBoundaryPoints[3].y);
    for (_i = 0, _len = currentBoundaryPoints.length; _i < _len; _i++) {
      point = currentBoundaryPoints[_i];
      context.lineTo(point.x, point.y);
    }
    context.closePath();
    return context.stroke();
  };

  normalizePoint = function(point) {
    return (point - 250) / 150;
  };

  update = function(delta) {
    var ball, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = balls.length; _i < _len; _i++) {
      ball = balls[_i];
      ball.posX = ball.posX + ball.velocityX * delta;
      _results.push(ball.posY = ball.posY + ball.velocityY * delta);
    }
    return _results;
  };

  render = function() {
    var ball, currentXVelocity, currentYVelocity, distance, normalVelocity, plane, _i, _len, _results;
    util.clearCanvas();
    drawBoundaries();
    _results = [];
    for (_i = 0, _len = balls.length; _i < _len; _i++) {
      ball = balls[_i];
      util.drawBall(ball, BALL_RADIUS);
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (_j = 0, _len1 = planes.length; _j < _len1; _j++) {
          plane = planes[_j];
          distance = (normalizePoint(ball.posX) * plane.x) + (normalizePoint(ball.posY) * plane.y) + plane.dist;
          currentXVelocity = ball.velocityX;
          currentYVelocity = ball.velocityY;
          normalVelocity = (currentXVelocity * plane.x) + (currentYVelocity * plane.y);
          if (distance < 0 && normalVelocity < 0) {
            ball.velocityX = currentXVelocity - (2 * plane.x * ((currentXVelocity * plane.x) + (currentYVelocity * plane.y)));
            _results1.push(ball.velocityY = currentYVelocity - (2 * plane.y * ((currentXVelocity * plane.x) + (currentYVelocity * plane.y))));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  recalculateNormal = function(plane, corner1, corner2) {
    plane.x = normalizePoint((corner1.x + corner2.x) / 2);
    plane.y = normalizePoint((corner1.y + corner2.y) / 2);
    return plane.dist = Math.sqrt(Math.pow(plane.x, 2) + Math.pow(plane.y, 2));
  };

  rotateSquare = function(degrees) {
    var i, newPoint, originPoint, radians, _i;
    radians = degrees * Math.PI / 180;
    for (i = _i = 0; _i <= 3; i = ++_i) {
      originPoint = rotationBounds[i];
      newPoint = currentBoundaryPoints[i];
      newPoint.x = (originPoint.x * Math.cos(radians)) + (originPoint.y * Math.sin(radians)) + 250;
      newPoint.y = (originPoint.x * -Math.sin(radians)) + (originPoint.y * Math.cos(radians)) + 250;
    }
    recalculateNormal(planes[0], currentBoundaryPoints[0], currentBoundaryPoints[1]);
    recalculateNormal(planes[1], currentBoundaryPoints[1], currentBoundaryPoints[2]);
    recalculateNormal(planes[2], currentBoundaryPoints[2], currentBoundaryPoints[3]);
    return recalculateNormal(planes[3], currentBoundaryPoints[3], currentBoundaryPoints[0]);
  };

  mainLoop = function() {
    var delta, now;
    now = Date.now();
    delta = (now - lastTime) / 1000;
    update(delta);
    render();
    lastTime = now;
    return window.requestAnimationFrame(mainLoop);
  };

  init = function() {
    rotateSquare(rotationAngle);
    drawBoundaries();
    lastTime = Date.now();
    return mainLoop();
  };

  $(document).ready(init);

}).call(this);
