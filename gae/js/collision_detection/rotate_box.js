// Generated by CoffeeScript 1.3.1
(function() {
  var balls, clearCanvas, currentBoundaryPoints, drawBall, drawBoundaries, frameTimer, init, nextFrame, normalizePoint, planes, recalculateNormal, rotateSquare, rotationAngle, rotationBounds;

  rotationAngle = 35;

  rotationBounds = [
    {
      x: -150,
      y: 150
    }, {
      x: 150,
      y: 150
    }, {
      x: 150,
      y: -150
    }, {
      x: -150,
      y: -150
    }
  ];

  currentBoundaryPoints = [
    {
      x: 100,
      y: 100
    }, {
      x: 400,
      y: 100
    }, {
      x: 400,
      y: 400
    }, {
      x: 100,
      y: 400
    }
  ];

  planes = [
    {
      x: 0,
      y: 1,
      dist: 1
    }, {
      x: 1,
      y: 0,
      dist: 1
    }, {
      x: 0,
      y: -1,
      dist: 1
    }, {
      x: -1,
      y: 0,
      dist: 1
    }
  ];

  balls = [
    {
      velocityX: 2,
      velocityY: 1,
      posX: 250,
      posY: 250
    }, {
      velocityX: -2,
      velocityY: 4,
      posX: 250,
      posY: 250
    }, {
      velocityX: 1,
      velocityY: -2,
      posX: 250,
      posY: 250
    }, {
      velocityX: 1,
      velocityY: -3,
      posX: 250,
      posY: 250
    }
  ];

  frameTimer = null;

  clearCanvas = function() {
    var context;
    context = document.getElementById("bounds").getContext('2d');
    return context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  };

  drawBall = function(ball) {
    var context;
    context = document.getElementById("bounds").getContext('2d');
    context.beginPath();
    context.moveTo(ball.posX, ball.posY);
    context.arc(ball.posX, ball.posY, 10, 0, Math.PI * 2, false);
    context.closePath();
    context.fill();
    return context.stroke();
  };

  drawBoundaries = function() {
    var context, point, _i, _len;
    context = document.getElementById("bounds").getContext('2d');
    context.beginPath();
    context.strokeStyle = "#000";
    context.moveTo(currentBoundaryPoints[3].x, currentBoundaryPoints[3].y);
    for (_i = 0, _len = currentBoundaryPoints.length; _i < _len; _i++) {
      point = currentBoundaryPoints[_i];
      context.lineTo(point.x, point.y);
    }
    context.closePath();
    return context.stroke();
  };

  normalizePoint = function(point) {
    return (point - 250) / 150;
  };

  nextFrame = function() {
    var ball, currentXVelocity, currentYVelocity, distance, normalVelocity, plane, _i, _j, _len, _len1;
    clearCanvas();
    drawBoundaries();
    for (_i = 0, _len = balls.length; _i < _len; _i++) {
      ball = balls[_i];
      ball.posX = ball.posX + ball.velocityX;
      ball.posY = ball.posY + ball.velocityY;
      drawBall(ball);
      for (_j = 0, _len1 = planes.length; _j < _len1; _j++) {
        plane = planes[_j];
        distance = (normalizePoint(ball.posX) * plane.x) + (normalizePoint(ball.posY) * plane.y) + plane.dist;
        currentXVelocity = ball.velocityX;
        currentYVelocity = ball.velocityY;
        normalVelocity = (currentXVelocity * plane.x) + (currentYVelocity * plane.y);
        if (distance < 0 && normalVelocity < 0) {
          ball.velocityX = currentXVelocity - (2 * plane.x * ((currentXVelocity * plane.x) + (currentYVelocity * plane.y)));
          ball.velocityY = currentYVelocity - (2 * plane.y * ((currentXVelocity * plane.x) + (currentYVelocity * plane.y)));
        }
      }
    }
    return frameTimer = setTimeout(nextFrame, 10);
  };

  recalculateNormal = function(plane, corner1, corner2) {
    plane.x = normalizePoint((corner1.x + corner2.x) / 2);
    plane.y = normalizePoint((corner1.y + corner2.y) / 2);
    return plane.dist = Math.sqrt(Math.pow(plane.x, 2) + Math.pow(plane.y, 2));
  };

  rotateSquare = function(degrees) {
    var i, newPoint, originPoint, radians, _i;
    radians = degrees * Math.PI / 180;
    for (i = _i = 0; _i <= 3; i = ++_i) {
      originPoint = rotationBounds[i];
      newPoint = currentBoundaryPoints[i];
      newPoint.x = (originPoint.x * Math.cos(radians)) + (originPoint.y * Math.sin(radians)) + 250;
      newPoint.y = (originPoint.x * -Math.sin(radians)) + (originPoint.y * Math.cos(radians)) + 250;
    }
    recalculateNormal(planes[0], currentBoundaryPoints[0], currentBoundaryPoints[1]);
    recalculateNormal(planes[1], currentBoundaryPoints[1], currentBoundaryPoints[2]);
    recalculateNormal(planes[2], currentBoundaryPoints[2], currentBoundaryPoints[3]);
    return recalculateNormal(planes[3], currentBoundaryPoints[3], currentBoundaryPoints[0]);
  };

  init = function() {
    rotateSquare(rotationAngle);
    drawBoundaries();
    return frameTimer = setTimeout(nextFrame, 10);
  };

  $(document).ready(init);

}).call(this);
