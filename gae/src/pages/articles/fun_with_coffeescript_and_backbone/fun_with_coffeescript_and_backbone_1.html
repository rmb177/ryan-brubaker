{% extends "base.html" %}

{% block content %}

<h3>Fun with Coffeescript and Backbone.js (Part 1)</h3>

<p>
   <a href="http://coffeescript.org/">CoffeeScript</a> has been all the rage lately and I’ve been wanting to hop on 
   board the bandwagon. I’ve also seen 
   <a href="http://backbonejs.org/">Backbone.js</a> mentioned quite a bit and was even more intrigued after listening 
   to this 
   <a href="http://www.dotnetrocks.com/default.aspx?showNum=743">.NET Rocks podcast</a>. 
   I decided to convert some plain JavaScript code I had in a side project to use both CoffeeScript and 
   Backbone.js and see how things went.
</p>

<p>
   The project is a simplified morse code simulator that animates morse code being sent over a telegraph line. The 
   complete source is available <a href="https://github.com/rmb177/MorseCode">here</a> and the running code can be 
   seen <a href="/doodles/MorseCode">here</a>.   
</p>

<p>
   In this post I’ll discuss the code that handles the user input.
</p>


<h5>Initialization</h5>
<script src="https://gist.github.com/2872348.js"></script>


<p>
   The init function sets up all of the Backbone.js model/view classes. Note that each Backbone view is initialized 
   with both its corresponding HTML element and corresponding model object.
</p>

<p>
   The init function also draws the “communication line” in a canvas element.
</p>


<script src="https://gist.github.com/2872351.js"></script>

<h5>Input View</h5>

<p>
   The application processes user input using the StraighKeyInput class, a Backbone view class associated with an input 
   button:
</p>

<script src="https://gist.github.com/2872372.js"></script>


<p>
   The class uses two timers to determine which “token” a user intends to send across the line. Using Backbone’s 
   declarative style for event binding, I bind the mousedown event to a function that starts both timers. The mouseup 
   event is bound to a function that pushes the appropriate token to the model based on how long the user held down 
   the input button.
</p>

<h5>Input Model</h5>

<p>
   The application processes user input using the StraighKeyInput class, a Backbone view class associated with an 
   input button:
</p>

<script src="https://gist.github.com/2872411.js"></script>

<p>
   The CommunicationLine class is a Backbone model class that represents the tokens currently moving across the 
   telegraph line. It also contains a queue that holds the input tokens generated by the user. The class also holds 
   a reference to the object responsible for decoding the user input (more on that tomorrow).
</p>

<p>
   Every 100 milliseconds, the communication line shifts its tokens over one spot. The token popped off the line is 
   passed to the decoder. The model then checks the input queue to determine if a user-generated token is available to 
   be pushed onto the line. If not, the model pushes a default token (an empty string). The model then triggers an event
   to indicate the communication line state has changed and that the object representing the communication line view needs
   to be re-rendered (more on that tomorrow).
</p>

<br />
<p class="attribution">
Originally published by my former employer, &copy; Art &amp; Logic: 
<a href="https://artandlogic.com/2012/06/fun-with-coffeescript-and-backbone-js-part-1">Fun with Coffeescript and Backbone.js (Part 1)</a>
</p>

{% endblock content %}
